// Code generated by ent, DO NOT EDIT.
// ------------------------------------------------------------------------
// SPDX-FileCopyrightText: Copyright Â© 2024 The Protobom Authors
// SPDX-FileType: SOURCE
// SPDX-License-Identifier: Apache-2.0
// ------------------------------------------------------------------------
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ------------------------------------------------------------------------

package edgetype

import (
	"fmt"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
)

const (
	// Label holds the string label denoting the edgetype type in the database.
	Label = "edge_type"
	// FieldID holds the string denoting the id field in the database.
	FieldID = "id"
	// FieldType holds the string denoting the type field in the database.
	FieldType = "type"
	// FieldNodeID holds the string denoting the node_id field in the database.
	FieldNodeID = "node_id"
	// FieldToID holds the string denoting the to_id field in the database.
	FieldToID = "to_id"
	// EdgeFrom holds the string denoting the from edge name in mutations.
	EdgeFrom = "from"
	// EdgeTo holds the string denoting the to edge name in mutations.
	EdgeTo = "to"
	// Table holds the table name of the edgetype in the database.
	Table = "edge_types"
	// FromTable is the table that holds the from relation/edge.
	FromTable = "edge_types"
	// FromInverseTable is the table name for the Node entity.
	// It exists in this package in order to avoid circular dependency with the "node" package.
	FromInverseTable = "nodes"
	// FromColumn is the table column denoting the from relation/edge.
	FromColumn = "node_id"
	// ToTable is the table that holds the to relation/edge.
	ToTable = "edge_types"
	// ToInverseTable is the table name for the Node entity.
	// It exists in this package in order to avoid circular dependency with the "node" package.
	ToInverseTable = "nodes"
	// ToColumn is the table column denoting the to relation/edge.
	ToColumn = "to_id"
)

// Columns holds all SQL columns for edgetype fields.
var Columns = []string{
	FieldID,
	FieldType,
	FieldNodeID,
	FieldToID,
}

// ValidColumn reports if the column name is valid (part of the table columns).
func ValidColumn(column string) bool {
	for i := range Columns {
		if column == Columns[i] {
			return true
		}
	}
	return false
}

// Type defines the type for the "type" enum field.
type Type string

// Type values.
const (
	TypeUNKNOWN              Type = "UNKNOWN"
	TypeAmends               Type = "amends"
	TypeAncestor             Type = "ancestor"
	TypeBuildDependency      Type = "buildDependency"
	TypeBuildTool            Type = "buildTool"
	TypeContains             Type = "contains"
	TypeContainedBy          Type = "contained_by"
	TypeCopy                 Type = "copy"
	TypeDataFile             Type = "dataFile"
	TypeDependencyManifest   Type = "dependencyManifest"
	TypeDependsOn            Type = "dependsOn"
	TypeDependencyOf         Type = "dependencyOf"
	TypeDescendant           Type = "descendant"
	TypeDescribes            Type = "describes"
	TypeDescribedBy          Type = "describedBy"
	TypeDevDependency        Type = "devDependency"
	TypeDevTool              Type = "devTool"
	TypeDistributionArtifact Type = "distributionArtifact"
	TypeDocumentation        Type = "documentation"
	TypeDynamicLink          Type = "dynamicLink"
	TypeExample              Type = "example"
	TypeExpandedFromArchive  Type = "expandedFromArchive"
	TypeFileAdded            Type = "fileAdded"
	TypeFileDeleted          Type = "fileDeleted"
	TypeFileModified         Type = "fileModified"
	TypeGenerates            Type = "generates"
	TypeGeneratedFrom        Type = "generatedFrom"
	TypeMetafile             Type = "metafile"
	TypeOptionalComponent    Type = "optionalComponent"
	TypeOptionalDependency   Type = "optionalDependency"
	TypeOther                Type = "other"
	TypePackages             Type = "packages"
	TypePatch                Type = "patch"
	TypePrerequisite         Type = "prerequisite"
	TypePrerequisiteFor      Type = "prerequisiteFor"
	TypeProvidedDependency   Type = "providedDependency"
	TypeRequirementFor       Type = "requirementFor"
	TypeRuntimeDependency    Type = "runtimeDependency"
	TypeSpecificationFor     Type = "specificationFor"
	TypeStaticLink           Type = "staticLink"
	TypeTest                 Type = "test"
	TypeTestCase             Type = "testCase"
	TypeTestDependency       Type = "testDependency"
	TypeTestTool             Type = "testTool"
	TypeVariant              Type = "variant"
)

func (_type Type) String() string {
	return string(_type)
}

// TypeValidator is a validator for the "type" field enum values. It is called by the builders before save.
func TypeValidator(_type Type) error {
	switch _type {
	case TypeUNKNOWN, TypeAmends, TypeAncestor, TypeBuildDependency, TypeBuildTool, TypeContains, TypeContainedBy, TypeCopy, TypeDataFile, TypeDependencyManifest, TypeDependsOn, TypeDependencyOf, TypeDescendant, TypeDescribes, TypeDescribedBy, TypeDevDependency, TypeDevTool, TypeDistributionArtifact, TypeDocumentation, TypeDynamicLink, TypeExample, TypeExpandedFromArchive, TypeFileAdded, TypeFileDeleted, TypeFileModified, TypeGenerates, TypeGeneratedFrom, TypeMetafile, TypeOptionalComponent, TypeOptionalDependency, TypeOther, TypePackages, TypePatch, TypePrerequisite, TypePrerequisiteFor, TypeProvidedDependency, TypeRequirementFor, TypeRuntimeDependency, TypeSpecificationFor, TypeStaticLink, TypeTest, TypeTestCase, TypeTestDependency, TypeTestTool, TypeVariant:
		return nil
	default:
		return fmt.Errorf("edgetype: invalid enum value for type field: %q", _type)
	}
}

// OrderOption defines the ordering options for the EdgeType queries.
type OrderOption func(*sql.Selector)

// ByID orders the results by the id field.
func ByID(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldID, opts...).ToFunc()
}

// ByType orders the results by the type field.
func ByType(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldType, opts...).ToFunc()
}

// ByNodeID orders the results by the node_id field.
func ByNodeID(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldNodeID, opts...).ToFunc()
}

// ByToID orders the results by the to_id field.
func ByToID(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldToID, opts...).ToFunc()
}

// ByFromField orders the results by from field.
func ByFromField(field string, opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newFromStep(), sql.OrderByField(field, opts...))
	}
}

// ByToField orders the results by to field.
func ByToField(field string, opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newToStep(), sql.OrderByField(field, opts...))
	}
}
func newFromStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(FromInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.M2O, false, FromTable, FromColumn),
	)
}
func newToStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(ToInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.M2O, false, ToTable, ToColumn),
	)
}
